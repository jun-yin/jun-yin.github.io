(()=>{"use strict";function t(){return e}const e=new CSSStyleSheet;function n(e){const n=e.getAttribute(":tag");if(!n)return;const l=[t()];for(const t of[...e.content.querySelectorAll("style")]){const e=new CSSStyleSheet;e.replaceSync(t.textContent||""),l.push(e),t.remove()}const s=[],o={},i=e.content.querySelector("hy-host");i&&([...i.childNodes].forEach((t=>{e.content.appendChild(t)})),i.classList.length>0&&s.push(...i.classList),[...i.attributes].forEach((t=>{"class"!==t.name&&(o[t.name]=t.value)})),i.remove());const a=e.content.cloneNode(!0);e.remove(),customElements.define(n,class extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.adoptedStyleSheets=l,this.shadowRoot.appendChild(a.cloneNode(!0)),s.length>0&&this.classList.add(...s);for(const[t,e]of Object.entries(o))this.setAttribute(t,e)}})}e.replaceSync("\n  *,\n  :host {\n    box-sizing: border-box;\n\n    /** ===== Rules for self ===== */\n\n    &[\\:clip] {\n      overflow: hidden;\n    }\n\n    &[\\:inline] {\n      display: inline-flex;\n    }\n\n    &[\\:layout='horiz'] {\n      display: flex;\n      flex-direction: row;\n      justify-content: flex-start;\n      align-items: flex-start;\n    }\n\n    &[\\:layout='vert'] {\n      display: flex;\n      flex-direction: column;\n      justify-content: flex-start;\n      align-items: flex-start;\n    }\n\n    &[\\:layout='wrap'] {\n      display: flex;\n      flex-direction: row;\n      flex-wrap: wrap;\n    }\n\n    &[\\:align~='center']:not([\\:align~='top']):not([\\:align~='bottom']):not([\\:align~='baseline']):not(\n        [\\:align~='left']\n      ):not([\\:align~='right']) {\n      justify-content: center;\n      align-items: center;\n    }\n\n    &[\\:layout='horiz'],\n    &[\\:layout='wrap'] {\n      /* Sets align-item */\n      &[\\:align~='top'] {\n        align-items: flex-start;\n      }\n      &[\\:align~='bottom'] {\n        align-items: flex-end;\n      }\n      &[\\:align~='baseline'] {\n        align-items: baseline;\n      }\n      &[\\:align~='center'] {\n        &[\\:align~='left'],\n        &[\\:align~='right'] {\n          align-items: center;\n        }\n      }\n\n      /* Sets justify-content */\n      &[\\:align~='left'] {\n        justify-content: flex-start;\n      }\n      &[\\:align~='right'] {\n        justify-content: flex-end;\n      }\n      &[\\:align~='center'] {\n        &[\\:align~='top'],\n        &[\\:align~='bottom'],\n        &[\\:align~='baseline'] {\n          justify-content: center;\n        }\n      }\n    }\n\n    &[\\:layout='vert'] {\n      /* Sets justify-content */\n      &[\\:align~='top'] {\n        justify-content: flex-start;\n      }\n      &[\\:align~='bottom'] {\n        justify-content: flex-end;\n      }\n      &[\\:align~='baseline'] {\n        justify-content: baseline;\n      }\n      &[\\:align~='center'] {\n        &[\\:align~='left'],\n        &[\\:align~='right'] {\n          justify-content: center;\n        }\n      }\n\n      /* Sets align-item */\n      &[\\:align~='left'] {\n        align-items: flex-start;\n      }\n      &[\\:align~='right'] {\n        align-items: flex-end;\n      }\n      &[\\:align~='center'] {\n        &[\\:align~='top'],\n        &[\\:align~='bottom'],\n        &[\\:align~='baseline'] {\n          align-items: center;\n        }\n      }\n    }\n\n    /** ===== Rules for children ===== */\n\n    &[\\:layout='horiz'],\n    &[\\:layout='wrap'] {\n      & > [\\:w='fill'] {\n        flex: 1 0 0;\n      }\n      & > [\\:h='fill'] {\n        align-self: stretch;\n      }\n      & > [\\:w='fill']:not([\\:layout]),\n      & > [\\:h='fill']:not([\\:layout]) {\n        display: block;\n      }\n      & > [\\:w='hug'] {\n        flex: 0 0 auto;\n      }\n\n      /** Child override */\n      & > [\\:h='hug'][\\:align-self~='top'] {\n        align-self: flex-start;\n      }\n      & > [\\:h='hug'][\\:align-self~='bottom'] {\n        align-self: flex-end;\n      }\n      & > [\\:h='hug'][\\:align-self~='baseline'] {\n        align-self: flex-end;\n      }\n      &\n        > [\\:h='hug'][\\:align-self~='center']:not([\\:align-self~='top']):not([\\:align-self~='bottom']):not(\n          [\\:align-self~='baseline']\n        ) {\n        align-self: center;\n      }\n    }\n\n    &[\\:layout='vert'] {\n      /* Sets children */\n      & > [\\:h='fill'] {\n        flex: 1 0 0;\n      }\n      & > [\\:w='fill'] {\n        align-self: stretch;\n      }\n      & > [\\:h='fill']:not([\\:layout]),\n      & > [\\:w='fill']:not([\\:layout]) {\n        display: block;\n      }\n      & > [\\:h='hug'] {\n        flex: 0 0 auto;\n      }\n\n      /** Child override */\n      & > [\\:w='hug'][\\:align-self~='left'] {\n        align-self: flex-start;\n      }\n      & > [\\:w='hug'][\\:align-self~='right'] {\n        align-self: flex-end;\n      }\n      & > [\\:w='hug'][\\:align-self~='center']:not([\\:align-self~='left']):not([\\:align-self~='right']) {\n        align-self: center;\n      }\n    }\n  }\n\n  slot[\\:layout='horiz'],\n  slot[\\:layout='wrap'] {\n    &::slotted([\\:w='fill']) {\n      flex: 1 0 0;\n    }\n    &::slotted([\\:h='fill']) {\n      align-self: stretch;\n    }\n    &::slotted([\\:w='fill']:not([\\:layout])),\n    &::slotted([\\:h='fill']:not([\\:layout])) {\n      display: block;\n    }\n    &::slotted([\\:w='hug']) {\n      flex: 0 0 auto;\n    }\n\n    /** Child override */\n    &::slotted([\\:h='hug'][\\:align-self~='top']) {\n      align-self: flex-start;\n    }\n    &::slotted([\\:h='hug'][\\:align-self~='bottom']) {\n      align-self: flex-end;\n    }\n    &::slotted([\\:h='hug'][\\:align-self~='baseline']) {\n      align-self: flex-end;\n    }\n    &::slotted(\n        [\\:h='hug'][\\:align-self~='center']:not([\\:align-self~='top']):not([\\:align-self~='bottom']):not(\n            [\\:align-self~='baseline']\n          )\n      ) {\n      align-self: center;\n    }\n  }\n\n  slot[\\:layout='vert'] {\n    &::slotted([\\:h='fill']) {\n      flex: 1 0 0;\n    }\n    &::slotted([\\:w='fill']) {\n      align-self: stretch;\n    }\n    &::slotted([\\:h='fill']:not([\\:layout])),\n    &::slotted([\\:w='fill']:not([\\:layout])) {\n      display: block;\n    }\n    &::slotted([\\:h='hug']) {\n      flex: 0 0 auto;\n    }\n    /** Child override */\n    &::slotted([\\:w='hug'][\\:align-self~='left']) {\n      align-self: flex-start;\n    }\n    &::slotted([\\:w='hug'][\\:align-self~='right']) {\n      align-self: flex-end;\n    }\n    &::slotted([\\:w='hug'][\\:align-self~='center']:not([\\:align-self~='left']):not([\\:align-self~='right'])) {\n      align-self: center;\n    }\n  }\n\n  :host([\\:layout='horiz']),\n  :host([\\:layout='wrap']) {\n    & > slot::slotted([\\:w='fill']) {\n      flex: 1 0 0;\n    }\n    & > slot::slotted([\\:h='fill']) {\n      align-self: stretch;\n    }\n    & > slot::slotted([\\:w='fill']:not([\\:layout])),\n    & > slot::slotted([\\:h='fill']:not([\\:layout])) {\n      display: block;\n    }\n    & > slot::slotted([\\:w='hug']) {\n      flex: 0 0 auto;\n    }\n\n    /** Child override */\n    & > slot::slotted([\\:h='hug'][\\:align-self~='top']) {\n      align-self: flex-start;\n    }\n    & > slot::slotted([\\:h='hug'][\\:align-self~='bottom']) {\n      align-self: flex-end;\n    }\n    & > slot::slotted([\\:h='hug'][\\:align-self~='baseline']) {\n      align-self: flex-end;\n    }\n    &\n      > slot::slotted(\n        [\\:h='hug'][\\:align-self~='center']:not([\\:align-self~='top']):not([\\:align-self~='bottom']):not(\n            [\\:align-self~='baseline']\n          )\n      ) {\n      align-self: center;\n    }\n  }\n\n  :host([\\:layout='vert']) {\n    & > slot::slotted([\\:h='fill']) {\n      flex: 1 0 0;\n    }\n    & > slot::slotted([\\:w='fill']) {\n      align-self: stretch;\n    }\n    & > slot::slotted([\\:h='fill']:not([\\:layout])),\n    & > slot::slotted([\\:w='fill']:not([\\:layout])) {\n      display: block;\n    }\n    & > slot::slotted([\\:h='hug']) {\n      flex: 0 0 auto;\n    }\n\n    /** Child override */\n    & > slot::slotted([\\:w='hug'][\\:align-self~='left']) {\n      align-self: flex-start;\n    }\n    & > slot::slotted([\\:w='hug'][\\:align-self~='right']) {\n      align-self: flex-end;\n    }\n    &\n      > slot::slotted(\n        [\\:w='hug'][\\:align-self~='center']:not([\\:align-self~='left']):not([\\:align-self~='right'])\n      ) {\n      align-self: center;\n    }\n  }\n");class l extends HTMLElement{static define(){customElements.define("hy-define",l)}constructor(){super()}connectedCallback(){requestIdleCallback((()=>{try{this.defineElements()}finally{this.remove()}}))}defineElements(){for(const t of this.querySelectorAll("template"))n(t)}}function s(t,e){const n=e.split("/"),l=t.trim().split("/");l.pop();for(let t=0;t<n.length;t++)".."===n[t]?l.pop():"."!==n[t]&&l.push(n[t]);return l.join("/")}class o extends HTMLElement{static define(){customElements.define("hy-import",o)}constructor(){super()}connectedCallback(){requestIdleCallback((async()=>{try{await this.importHtml()}finally{this.remove()}}))}async importHtml(){let t=this.getAttribute("src");if(!t)return;if(!t.startsWith("/")&&!t.startsWith("https://")&&!t.startsWith("http://")){let e=this;for(;;){if(e instanceof Element&&e.hasAttribute(":import-src")){t=s(e.getAttribute(":import-src"),t);break}if(e=e&&e.parentNode,!e)break;e instanceof ShadowRoot&&(e=e.host)}}const e=await fetch(t);if(200!==e.status)return void console.error(e.statusText);const n=await e.text(),l=document.createRange().createContextualFragment(n);for(const e of l.childNodes)e instanceof HTMLElement&&e.setAttribute(":import-src",t);this.parentNode?.insertBefore(l,this)}}function i(t){const e={null:null,values:{}};for(const n of t.querySelectorAll("map-item")){let t=null,l=null;n.hasAttribute("from")&&(t=n.getAttribute("from")),n.hasAttribute("to")&&(l=n.getAttribute("to")),null===t?e.null=l:e.values[t]=l}return null!==e.null||Object.keys(e.values).length>0?e:void 0}class a extends HTMLElement{static define(){customElements.define("hy-listen",a)}eventListeners=[];mutationObservers=[];root=null;parent=null;handlingEvent=!1;constructor(){super()}connectedCallback(){this.unlistenAll(),this.initializeListeners()}initializeListeners(){if(this.parent=this.parentElement,this.parent)this.root=this.parent;else{const t=this.getRootNode();if(!(t instanceof ShadowRoot))return;this.root=t,this.parent=t.host}const t=this.getAttribute("target");if(!t)return void console.error('"target" must be set for <hy-listen>:',this.outerHTML);const e=":root"===t,n=":host"===t,l=e?[this.root]:n?[this.parent]:this.root.querySelectorAll(t);if(!l||0===l.length)return;const s=this.getAttribute("on");if(!s)return void console.error('"event" must be set for <hy-listen>:',this.outerHTML);let o=!1,i="",a=null;switch(s){case"attribute":for(const t of l){const n=this.getAttribute("name")||"",l=this.getAttribute("value"),s=new MutationObserver((t=>{for(const e of t)if("attributes"===e.type&&e.attributeName?.match(n)&&e.target instanceof Element&&(null===l||e.target.getAttribute(e.attributeName)?.match(l))){this.handleEvent(e.target.getAttribute(e.attributeName),e.target);break}}));if(s.observe(t,{attributes:!0,subtree:e}),this.mutationObservers.push(s),!o)if(t instanceof Element)if(null!==l){for(const e of t.attributes)if(e.name.match(n)&&t.getAttribute(e.name)?.match(l)){o=!0,i=e.value||"",a=t;break}}else o=!0,i=t.getAttribute(n),a=t;else o=!0,a=t}break;default:if(s.startsWith("key")){for(const t of l){const e=this.getAttribute("key"),n=this.getAttribute("modifier")?.toLowerCase(),l=l=>{const s=l;let o=!1;o||=!!e&&!s.key.toLowerCase().match(e),!o&&n&&(o||=n.includes("ctrl")!==s.ctrlKey||n.includes("alt")!==s.altKey||n.includes("shift")!==s.shiftKey||n.includes("meta")!==s.metaKey),o||this.handleEvent(null,t)};t.addEventListener("keydown",l,!0),this.eventListeners.push({target:t,event:s,listener:l,capture:!0})}break}for(const t of l){const e=e=>{this.handleEvent(null,t)};t.addEventListener(s,e,!0),this.eventListeners.push({target:t,event:s,listener:e,capture:!0})}}o&&null!==a&&this.handleEvent(i,a)}unlistenAll(){for(const t of this.eventListeners)t.target.removeEventListener(t.event,t.listener,t.capture);this.eventListeners=[],this.mutationObservers.forEach((t=>{t.disconnect()})),this.mutationObservers=[]}handleEvent(t="",e){if(this.handlingEvent||!this.parent||!this.root)return;this.handlingEvent=!0,this.getAttribute("on");const n=new Map;for(const l of this.children){const s=l.getAttribute("target");if(!s){console.error('"target" must be set for actions of <hy-listen>:',l.outerHTML);continue}this.getAttribute("target");const o=":host"===s?[this.parent]:this.root.querySelectorAll(s);if(o&&0!==o.length)switch(l.tagName.toLowerCase()){case"remove-value":{const t=l.getAttribute("attr"),e=l.hasAttribute("content");t&&o.forEach((e=>{e.removeAttribute(t)})),e&&o.forEach((t=>{t.textContent=""}));break}case"set-value":{const t=(l.hasAttribute("value")?l.getAttribute("value")?.trim():l.textContent?.trim())||"",e=l.getAttribute("attr"),n=l.getAttribute("prop"),s=l.hasAttribute("content");if(e&&o.forEach((n=>{n.setAttribute(e,t)})),n){const e=r(t);o.forEach((t=>{t[n]=e}))}s&&o.forEach((e=>{e.textContent=t}));break}case"rotate-value":{const t=[...l.querySelectorAll("list-item")].map((t=>t.hasAttribute("null")?null:t.getAttribute("value")));if(0===t.length)continue;const e=l.getAttribute("attr"),n=l.getAttribute("prop"),s=l.hasAttribute("content");e&&o.forEach((n=>{const l=t.indexOf(n.getAttribute(e)),s=t[(l+1)%t.length];null===s?n.removeAttribute(e):n.setAttribute(e,s)})),n&&o.forEach((e=>{const l=e,s=t.indexOf(f(l[n])),o=t[(s+1)%t.length]||"";l[n]=r(o)})),s&&o.forEach((e=>{const n=t.indexOf(e.textContent),l=t[(n+1)%t.length];e.textContent=l}));break}case"propagate-value":{if(!e){console.error("No event target for <propagate-value>");continue}const n=i(l),s=l.getAttribute("from-attr"),a=l.getAttribute("from-prop"),u=l.hasAttribute("from-content");let c=t;s&&e instanceof Element?c=e.getAttribute(s):a?c=f(e[a]):u&&(c=e.textContent),n&&null===c?c=n.null:n&&null!==c&&c in n.values&&(c=n.values[c]);const h=l.getAttribute("attr"),g=l.getAttribute("prop"),d=l.hasAttribute("content");if(h&&o.forEach((t=>{null===c?t.removeAttribute(h):t.setAttribute(h,c)})),g){const t=null===c?null:r(c);o.forEach((e=>{e[g]=t}))}d&&o.forEach((t=>{t.textContent=c}));break}case"toggle-class":{const t=l.getAttribute("match"),e=l.getAttribute("class");if(!e){console.error("<toggle-class> must have a class attribute");continue}const s=e.split(" ");o.forEach((e=>{if(t&&!this.root.querySelector(t))return void e.classList.remove(...s.filter((t=>!n.get(e)?.[t])));e.classList.add(...s);let l=n.get(e);l||(l={},n.set(e,l)),s.forEach((t=>{l[t]=!0}))}));break}}}n.clear(),requestIdleCallback((()=>{this.handlingEvent=!1}))}}function r(t){const e=t.match(/^(\s*):(\s*)$/),n=e&&e[1],l=e&&e[2];let s=t;return"num"===n?s=Number(l):"null"===n?s=null:"bool"===n?s="true"===l:"str"===n&&(s=l),s}function f(t){return"number"==typeof t?`num:${t}`:"boolean"==typeof t?`bool:${t}`:"string"==typeof t?`str:${t}`:null==t?"null:":""}document.adoptedStyleSheets=[...document.adoptedStyleSheets,t()],o.define(),l.define(),a.define()})();
